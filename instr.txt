This is a blog-like description of the process of figuring out
the ARMv7-A instruction set decoding.

At the end, there is some pseudocode about decoding the ARM instructions.

Most of the info needed here, to get started, was found from:
http://www.wss.co.uk/pinknoise/ARMinstrs/ARMinstrs.html#Instructions
Kudos!

The rest comes from "cross matching" ARMv7-A/R ARM, ARM ARM, ARMv8 ARM and
Cortex-A series Programmer's Guide.

---------------------------------------
Deciphering ARM istruction set encoding

1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx E    AL(Always)	      branch
1111xxxx xxxxxxxx xxxxxxxx xxxxxxxx F    NV(Never)	      linear
Others are true conditionals

 Data Processing Instructions

xxxx000a aaaSnnnn ddddcccc ctttmmmm  Register form
xxxx001a aaaSnnnn ddddrrrr bbbbbbbb  Immediate form
        ADDEQS Rd, Rn, Rm, ASL Rc
if dddd = 1111 (PC) then branch, otherwise linear

 Branch Instructions
xxxx101L oooooooo oooooooo oooooooo

oooo... = offset = (sign extended version of bits 0-23)
destination address = current address + 8 + (4 * offset)
L = with link register

 Multiplication / Long Multiplication (ARM7DM)
xxxx0000 1UAShhhh llllssss 1001mmmm
The program counter, R15 should not be used.

 Single Data Transfer

xxxx010P UBWLnnnn ddddoooo oooooooo  Immediate form
xxxx011P UBWLnnnn ddddcccc ctt0mmmm  Register form
If the immediate form of the instruction is used, the o field gives
a 12-bit offset
If R15 is used as Rd, the PSR is not modified. The PC should not be used in Op2. 
Don't use writeback or post-indexing when the base register is the PC.
Don't use the PC as Rd for an LDRB or STRB.

 Block Data Transfer

xxxx100P USWLnnnn llllllll llllllll
The U bit indicates whether the address will be modified by +4 (set),
or -4 (clear) for each register.
The W bit always indicates writeback.
If set, the L bit indicates a load operation should be performed.
If clear, a save.
The P bit is used indicate whether to increment/decrement
the base before or after each load/store (see the table below).

Bit l is set if Rl is to be loaded/stored by this operation. 
Stub	Meaning                         P	U
DA	Decrement Rn After each store/load	0	0
DB	Decrement Rn Before each store/load	1	0
IA	Increment Rn After each store/load	0	1
IB	Increment Rn Before each store/load	1	1
The PC should not be used as the base register.

 Software interrupt

xxxx1111 yyyyyyyy yyyyyyyy yyyyyyyy

 Co-processor data operations

xxxx1110 oooonnnn ddddpppp qqq0mmmm
       CDP p, o, CRd, CRn, CRm, q

 Co-processor data transfer and register transfers

xxxx110P UNWLnnnn DDDDpppp oooooooo LDC/STC
xxxx1110 oooLNNNN ddddpppp qqq1MMMM MRC/MCR
       LDCNEL p,CRd,[Rn],#-100 ;long form (N=1), post-indexed
Rd should not be R15 for an MCR instruction.
If Rd is R15 for an MRC instruction, the top 4 bits of the word
transferred are used to set the flags; the remaining 28 bits are discarded.

 Single Data Swap (ARM 3 and later including ARM 2aS)

xxxx0001 0B00nnnn dddd0000 1001mmmm
None of Rd, Rn, and Rm may be R15

 Status Register transfer (ARM 6 and later)

xxxx0001 0s10aaaa 11110000 0000mmmm  MSR  Register form
xxxx0011 0s10aaaa 1111rrrr bbbbbbbb  MSR  Immediate form
xxxx0001 0s001111 dddd0000 00000000  MRS
Rd must not be R15.

 Undefined instructions

xxxx0001 yyyyyyyy yyyyyyyy 1yy1yyyy ARM 2 only
xxxx011y yyyyyyyy yyyyyyyy yyy1yyyy
On encountering an undefined instruction, the ARM switches to
Undef mode and jumps to undef exception.

------------
arm instruction
xxxxgggf fffyyyyy yyyyyyyy yyyyyyyy

xxxx: condition code

classes (ggg):
000	Data Processing Instructions - register form
	Multiplication, R15 should not be used
	Single Data Swap, None of Rd, Rn, and Rm may be R15
	MSR  Register form, Rd must not be R15
	MRS, Rd must not be R15
	Undefined instructions - ARM 2 only
001	Data Processing Instructions - immediate form
	MSR  Immediate form
010	Single Data Transfer - immediate form, if Rd=PC, check
011	Single Data Transfer - register form, if Rd=PC, check
	Undefined instructions - undef exception
100	Block Data Transfer - check
101	Branch Instructions
110	LDC/STC - linear (check)
111	Software interrupt
	Co-processor data operations
	MRC/MCR, if Rd = PC, check

The ff-bits seem to make the secondary classification
(for data processing instructions), because in some instructions the
first 'x' is 'variable'. The xx-bits - especially bit-21, bit-4 and bit-20
seem to be tertiary decoding bits for some groups of data processing instructions.

The best way is probably to implement a function that returns the value of
given bit and a function thet returns the value formed by a range of adjacent bits,
because the order to apply the bitmasks varies depending on the group of
instructions to tell apart.

For example, MUL can be checked by main classification, bits 24-23 and bit 4.
Bits 22 and 21 don't are "instruction internal". Bits 24-21 can be used for
subclassification, but then MUL needs to be checked in 4 subclasses.

The data processing instructions are probably best decoded by first picking
out the 'special cases' and then decoding the rest (arith & logic) by bits 
24-20 and then bit 4.

Finding out the best way of decoding requires quite a study on the subject
and at least a list of instruction bitpatterns - one per line.

gggffhh
000	Data Processing Instructions - register form
	0000	AND     	Boolean And
	0001	EOR     	Boolean Eor
	0010	SUB     	Subtract
	0011	RSB     	Reverse Subtract

	0100	ADD     	Addition        	bit4=0
	0101	ADC     	Add with Carry   	bit4=0
	0110	SBC     	Subtract with carry 	bit4=0
	0111	RSC     	Reverse sub w/carry 	bit4=0
	01UA	Multiplication 					bit4=1

	1000	TST     	Test bit        	bit4=0, bit20=1
	1001	TEQ     	Test equality   	bit4=0
	1010	CMP     	Compare         	bit4=0, bit20=1
	1011	CMN     	Compare Negative	bit4=0
	10B0	SWP(B)		Swap 				bit4=1
	10s0	MRS 							bit4=0, bit9=1:bank, bit20=0
	10s1	MSR  Register form 				bit4=1, bit9=1:bank
	
	1100	ORR     	Boolean Or
	1101	MOV     	Move value
	1110	BIC     	Bit clear
	1111	MVN     	Move Not

001	Data Processing Instructions - immediate form
	0000	AND     	Boolean And
	0001	EOR     	Boolean Eor
	0010	SUB     	Subtract
	0011	RSB     	Reverse Subtract

	0100	ADD     	Addition
	0101	ADC     	Add with Carry
	0110	SBC     	Subtract with carry
	0111	RSC     	Reverse sub w/carry

	1000	TST     	Test bit			bit20=1
	1001	TEQ     	Test equality   	bit20=1
	1010	CMP     	Compare				bit20=1
	1010	MOVT		Move top			bit20=0
	1011	CMN     	Compare Negative	bit20=1
	10s1	MSR  Immediate form 			bit20=0

	1100	ORR     	Boolean Or
	1101	MOV     	Move value
	1110	BIC     	Bit clear
	1111	MVN     	Move Not
	
010
	PUBW	Single Data Transfer - immediate form, if Rd=PC, check
011
	PUBW	(bit4 = 0) Single Data Transfer - register form, if Rd=PC, check
	yyyy	(bit4 = 1) Undefined instructions - undef exception (still exist?)
			(bit4 = 1) Media instructions (Rd = PC is not allowed or is UNPREDICTABLE)
100	
	PUSW	Block Data Transfer - check
101
	L		B (branch, L = with link reg)
110	
	PUNW	LDC/STC
111
	0ooo	Co-processor data operations (bit4 = 0)
	0ooo	MRC/MCR (bit4 = 1)
	1yyy	Software interrupt


Branches:
conditional branches are 'B'-branches with condition code
31:28 = condition code
27:25 (class) = 101
24 = L (1 = with LR)
23:0 = signed imm (PC-offset)
With condition NV (1111) it becomes BLX, where bit 24 tells... what?
(Probably if bit 24 = '1' switch to THUMB-mode?)

Condition codes
          Mnemonic
cond  Meaning (integer)                  Meaning (floating-point) a               Condition flags
          extension
0000      EQ                Equal        Equal              Z == 1
0001      NE                Not equal    Not equal, or unordered                  Z == 0
0010      CS b              Carry set    Greater than, equal, or unordered        C == 1
0011      CC c              Carry clear  Less than          C == 0
0100      MI                Minus, negative                    Less than          N == 1
0101      PL                Plus, positive or zero             Greater than, equal, or unordered        N == 0
0110      VS                Overflow     Unordered          V == 1
0111      VC                No overflow  Not unordered      V == 0
1000      HI                Unsigned higher                    Greater than, or unordered               C == 1 and Z == 0
1001      LS                Unsigned lower or same             Less than or equal C == 0 or Z == 1
1010      GE                Signed greater than or equal       Greater than or equal                    N == V
1011      LT                Signed less than                   Less than, or unordered                  N != V
1100      GT                Signed greater than                Greater than       Z == 0 and N == V
1101      LE                Signed less than or equal          Less than, equal, or unordered           Z == 1 or N != V
1110      None (AL) d       Always (unconditional)             Always (unconditional)                   Any

    a. Unordered means at least one NaN operand.
    b. HS (unsigned higher or same) is a synonym for CS.
    c. LO (unsigned lower) is a synonym for CC.
    d. AL is an optional mnemonic extension for always, except in IT instructions. For details see IT on page A8-390.

For register ops: bits 11-0 is a shifter operand:
register: 11:7 imm, 6:5=type, 4=0, 3:0=Rm
register-shifted: 11:8 = Rs, 7=0. 6:5=type, 4=1, 3:0=Rm operand2=Rm <type> Rs
type:
00 = LSL
01 = LSR
10 = ASR
11 = ROR
modified imm: 11:8 rot, 7:0 imm
rot = number of double shifts right

LDC/LDC2/STC/STC2
110 PUNWL Rn=19:16  CRd=15:12 cpnum=11:8 wordoffset=7:0

N=1 long transfer
PUWL as with LDR/STR (no usermode access => W is always writeback), L=1:LDC (mem->Cp)
U must equal 1 or the result is either UNDEFINED or UNPREDICTABLE
wordoffset specifies the immediate offset that is multiplied by 4, then added to
or subtracted from the value of Rn to form the address


LDM/STM
100 PUSWL Rn=19:16 reglist=15:0
PUWL as with LDC/STC
S: For LDMs that load the PC, the S bit indicates that the CPSR is loaded from the SPSR. For
LDMs that do not load the PC and all STMs, the S bit indicates that when the processor is in a
privileged mode, the User mode banked registers are transferred instead of the registers of
the current mode.
reglist: bit n = Register n included into the list
The SP and PC can be in the list in ARM instructions, but not in Thumb instructions.
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE

Single data transfer:
cond 01A op1(24:20) Rn(19:16) .... Bit4 ...
op1 bits: PUBWL
P=0: post indexing. P=1 offset or pre indexing (indexing = offset + writeback)
U=offset sign (1=+, 0=-)
W:
  P=0: W= user mode access (1=user, 0=normal)
  P=1: W= writeback (1=writeback)
PW is like unit (or one field with separated bits):
00 = postindexing, normal
01 = usermode access, offset
10 = offset normal
11 = preindexing normal
B=byte, L=direction:1=load

LDR reg, LDRB reg:
if m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE
LDRT reg, LDRTB reg:
if PC is involved, UNPREDICTABLE
LDR imm, LDRB imm, LDRT imm, LDRTB imm:
Rd != PC
(A5.3           Load/store word and unsigned byte)
A op1
0 00000 STR imm
0 00001 LDR imm Rn != PC
0 00010	STRT
0 00011 LDRT 
0 00100 STRB imm
0 00101 LDRB imm Rn != PC
0 00110 STRBT
0 00111 LDRBT
0 01000 STR imm
0 01001 LDR imm Rn != PC
0 01010 STRT
0 01011 LDRT
0 01100 STRB imm
0 01101 LDRB imm Rn != PC
0 01110 STRBT
0 01111 LDRBT
0 10000 STR imm
0 10001 LDR imm Rn != PC
0 10010 STR imm
0 10011 LDR imm Rn != PC
0 10100 STRB imm
0 10101 LDRB imm Rn != PC
0 10110 STRB imm
0 10111 LDRB imm Rn != PC
0 11000 STR imm
0 11001 LDR imm Rn != PC
0 11010 STR imm
0 11011 LDR imm Rn != PC
0 11100 STRB imm
0 11101 LDRB imm Rn != PC
0 11110 STRB imm
0 11111 LDRB imm Rn != PC
1 00000 STR reg B=0
1 00001 LDR reg B=0
1 00010 STRT B=0
1 00011 LDRT B=0
1 00100 STRB reg B=0
1 00101 LDRB reg B=0
1 00110 STRBT B=0
1 00111 LDRBT B=0
1 01000 STR reg B=0
1 01001 LDR reg B=0
1 01010 STRT B=0
1 01011 LDRT B=0
1 01100 STRB reg B=0
1 01101 LDRB reg B=0
1 01110 STRBT B=0
1 01111 LDRBT B=0
1 10000 STR reg B=0
1 10001 LDR reg B=0
1 10010 STR reg B=0
1 10011 LDR reg B=0
1 10100 STRB reg B=0
1 10101 LDRB reg B=0
1 10110 STRB reg B=0
1 10111 LDRB reg B=0
1 11000 STR reg B=0
1 11001 LDR reg B=0
1 11010 STR reg B=0
1 11011 LDR reg B=0
1 11100 STRB reg B=0
1 11101 LDRB reg B=0
1 11110 STRB reg B=0
1 11111 LDRB reg B=0
All immediates (A=1) have bit4=0. If bit4=1 => media instruction

---------

get instr at PC (in register structure)
get T-bit from cpsr (in register structure)
// remember to set our T-bit before executing inferior's instructions.
if (T) get_thumb_info(PC)
else get_arm_info(PC)

----------

arm mode:
I learned from gdbserver sources that condition code checking is so small
thing that it should be done at the same time: just matching the condition
code against the status flags. Then we need only one breakpoint address.


instruction bits:
xxxxgggf fyyyyyyy yyyyyyyy yyyyyyyy
where xxxx is the condition code and ggg the class code.

condition code: 
if xxxx is NV special instruction (Unconditionals)
if xxxx is AL no branch
if xxxx matches cpsr then branch (only flags NZCV are involved)
else no branch

if no branch (operation is NOP) next address is PC + 4
else decode

Here is one way of ARM instruction decoding as pseudocode.
Seeing all the bit patterns of instructions at once might reveal better ways.

UPDATE: After creating a table of all ARM instruction encodings, the table showed
	that the pseudocode derived from the above doesn't work!
	
	The bits 27 - 25 (and only them) run as constants through the whole instruction
	table They are the only bits that can be counted on in all situations.
	if bits 27 - 25 = 0, the only 'constant' bit running through the whole subset
	is bit 4. If bit 4 = 0, then bit 24 is the only 'constant' (excluding instructions
	in ARMv7-A/R ARM B9.3.20).
	
	The old pseudocode is replaced by a new one that's based on the instruction table.
	

// This might be useful - there is no ^^ in C.
inline int log_xor(int val1, int val2)
{
	return ((val1 && (!val2)) || ((!val1) && val2));
}


ARM instruction decoding
When instruction is found, the "unnecessary" bits still need to be checked.
The decoding (nor encoding) is not complete (all bit patterns are not "in use").
Like in CLREX/DSB/DMB/ISB: They all must have bits 24 - 20 = 1 0 1 1 1.

PROC decode
	IF (condition code == NV) THEN
		CASEOF (bits 27 - 25)
			CASE 0:
				// CPS/SETEND
			ENDCASE
			
			CASE 2:
				IF (bit 21 == 0) THEN
					// PLI/PLD
				ELSE
					// CLREX/DSB/DMB/ISB
					// bits 7 - 4
				ENDIF
			ENDCASE
			
			CASE 3:
				// PLI/PLD
			ENDCASE
			
			CASE 4:
				// RFE/SRS
			ENDCASE
			
			CASE 5:
				// BLX
			ENDCASE
			
			OTHER:
				// empty
			ENDCASE
		ENDCASEOF
	ELSE
		CASEOF (bits 27 - 25) // main classification
			CASE 0:
				// Arith&log + LD/ST (reg)
				IF (bit 4 == 0) THEN
					CASEOF (bits 24-23)
						case 0:
							// Arith&logic  <Rd>,<Rn>,<Rm>{,<sift>}
							CASEOF (bits 22, 21)
								CASE 0:
									// AND
								ENDCASE
								
								CASE 1:
									// EOR
								ENDCASE
								
								CASE 2:
									// SUB
								ENDCASE
								
								CASE 3:
									// RBS
								ENDCASE
							ENDCASEOF
						ENDCASE
						
						case 1:
							// Arith&logic  <Rd>,<Rn>,<Rm>{,<sift>}
							CASEOF (bits 22, 21)
								CASE 0:
									// ADD
								ENDCASE
								
								CASE 1:
									// ADC
								ENDCASE
								
								CASE 2:
									// SBC
								ENDCASE
								
								CASE 3:
									// RSC
								ENDCASE
							ENDCASEOF
						ENDCASE
						
						CASE 2:
							IF (bit 20 == 0) THEN
								// specials
								IF (bit 7 == 0) THEN
									IF (bit 21 == 0) THEN
										// MRS, bit 9 = banked
									ELSE
										IF (bit 5 == 0) THEN
											// MSR, bit 9 = banked
										ELSE
											IF (bit 6 == 0) THEN
												// BXJ
											ELSE
												// ERET
											ENDIF
										ENDIF
									ENDIF
								ELSE // bit 7 == 1
									// 22, 21 (5)
									CASEOF (bits 22 - 21)
										CASE 0:
											// SMLA
										ENDCASE
										
										CASE 1:
											IF (bit 5 == 0) THEN
												// SMLAW
											ELSE
												// SMULW
											ENDIF
										ENDCASE
										
										CASE 2:
											// SMLAL
										ENDCASE
										
										CASE 3:
											// SMUL
										ENDCASE
									ENDCASEOF
								ENDIF
							ELSE
								CASEOF (bits 22 - 21)
									CASE 0:
										// TST
									ENDCASE
									
									CASE 1:
										// TEQ
									ENDCASE
									
									CASE 2:
										// CMP
									ENDCASE
									
									CASE 3:
										// CMN
									ENDCASE
								ENDCASEOF
							ENDIF
						ENDCASE
						
						case 3:
							// Arith&logic
							CASEOF (bits 22, 21)
								CASE 0:
									// ORR
								ENDCASE
								
								// <Rd>,<Rn>,<Rm>{,<sift>}
								CASE 1:
									// <Rd>,<Rm>,#<imm5>
									CASEOF (bits 6 -5)
										CASE 0:
											IF (bits 11 - 7 == 0) THEN
												// MOV
											ELSE
												// LSL
											ENDIF
										ENDCASE
										
										CASE 1:
											// LSR
										ENDCASE
										
										CASE 2:
											// ASR
										ENDCASE
										
										CASE 3:
											IF (bits 11 - 7 == 0) THEN
												// RRX
											ELSE
												// ROR
											ENDIF
										ENDCASE
									ENDCASEOF
								ENDCASE
								
								CASE 2:
									// BIC
								ENDCASE
								
								CASE 3:
									// MVN <Rd>,<Rm>{,<sift>}
								ENDCASE
							ENDCASEOF
						ENDCASE
					ENDCASEOF
				ELSE
					IF (bit 7 = 0) THEN
						// reg shifted reg
						CASEOF (bits 24-23)
							CASE 0:
								// Arith&logic <Rd>,<Rn>,<Rm>,<type>,<Rs>
								CASEOF (bits 22, 21)
									CASE 0:
										// AND
									ENDCASE
									
									CASE 1:
										// EOR
									ENDCASE
									
									CASE 2:
										// SUB
									ENDCASE
									
									CASE 3:
										// RSB
									ENDCASE
								ENDCASEOF
							ENDCASE
							
							CASE 1:
								// Arith&logic <Rd>,<Rn>,<Rm>,<type>,<Rs>
								CASEOF (bits 22, 21)
									CASE 0:
										// ADD
									ENDCASE
									
									CASE 1:
										// ADC
									ENDCASE
									
									CASE 2:
										// SBC
									ENDCASE
									
									CASE 3:
										// RSC
									ENDCASE
								ENDCASEOF
							ENDCASE
							
							CASE 2:
								IF (bit 20 == 0) THEN
									// specials: first bits 6,5 then 22,21
									CASEOF (bits 6 - 5)
										CASE 0:
											IF (bit 22 == 0) THEN
												// BX
											ELSE
												// CLZ
											ENDIF
										ENDCASE
										
										CASE 1:
											// BLX
										ENDCASE
										
										CASE 2:
											CASEOF (bits 22 - 21)
												CASE 0:
													// QADD
												ENDCASE
												
												CASE 1:
													// QSUB
												ENDCASE
												
												CASE 2:
													// QDADD
												ENDCASE
												
												CASE 3:
													// QDSUB
												ENDCASE
											ENDCASEOF
										ENDCASE
										
										CASE 3:
											CASEOF (bits 22 - 21)
												CASE 0:
													// empty
												ENDCASE
												
												CASE 1:
													// BKPT
												ENDCASE
												
												CASE 2:
													// HVC
												ENDCASE
												
												CASE 3:
													// SMC
												ENDCASE
											ENDCASEOF											
										ENDCASE
									ENDCASEOF
								ELSE
									CASEOF (bits 22 - 21)
										CASE 0:
											// TST
										ENDCASE
										
										CASE 1:
											// TEQ
										ENDCASE
										
										CASE 2:
											// CMP
										ENDCASE
										
										CASE 3:
											// CMN
										ENDCASE
									ENDCASEOF
								ENDIF
							ENDCASE

							CASE 3:
								// Arith&logic <Rd>,<Rn>,<Rm>,<type>,<Rs>
								CASEOF (bits 22, 21)
									CASE 0:
										// ORR
									ENDCASE
									
									CASE 1:
										//  <Rd>,<Rn>,<Rm>
										CASEOF (bits 6 - 5)
											CASE 0:
												// LSL
											ENDCASE
											
											CASE 1:
												// LSR
											ENDCASE
											
											CASE 2:
												// ASR
											ENDCASE
											
											CASE 3:
												// ROR
											ENDCASE
										ENDCASEOF
									ENDCASE
									
									CASE 2:
										// BIC
									ENDCASE
									
									CASE 3:
										// MVN
									ENDCASE
								ENDCASEOF
							ENDCASE
						ENDCASEOF
					ELSE
						CASEOF (bits 6 - 5)
							CASE 0:
								// specials: Multiply/STREX/LDREX
								CASEOF (bits 24 - 23)
									CASE 0:
										CASEOF (bits 22 - 21)
											CASE 0:
												// MULS
											ENDCASE
											
											CASE 1:
												// MLAS
											ENDCASE
											
											CASE 2:
												// UMAAL
											ENDCASE
											
											CASE 3:
												// MLS
											ENDCASE
										ENDCASEOF
									ENDCASE
									
									CASE 1:
										CASEOF (bits 22 - 21)
											CASE 0:
												// UMULL
											ENDCASE
											
											CASE 1:
												// UMLAL
											ENDCASE
											
											CASE 2:
												// SMULL
											ENDCASE
											
											CASE 3:
												// SMLAL
											ENDCASE
										ENDCASEOF
									ENDCASE
									
									CASE 2:
										// SWP(B)
									ENDCASE
									
									CASE 3:
										CASEOF (bits 22 - 20)
											CASE 0:
												// STREX
											ENDCASE
											
											CASE 1:
												// LDREX
											ENDCASE
											
											CASE 2:
												// STREXD
											ENDCASE
											
											CASE 3:
												// LDREXD
											ENDCASE
											CASE 4:
												// STREXB
											ENDCASE
											
											CASE 5:
												// LDREXB
											ENDCASE
											
											CASE 6:
												// STREXH
											ENDCASE
											
											CASE 7:
												// LDREXH
											ENDCASE
										ENDCASEOF
									ENDCASE
								ENDCASEOF
							ENDCASE

							CASE 1:
								// LDRH/STRH
								IF bit 20 == 0 THEN
									IF bit 22 == 0 THEN
										// STRHT/STRH reg
									ELSE
										// STRHT/STRH imm										
									ENDIF
								ELSE
									IF bit 22 == 0 THEN
										//LDRHT/LDRH reg
									ELSE
										//LDRHT/LDRH imm
									ENDIF
								ENDIF
							ENDCASE

							CASE 2:
								// LDRD/LDRS
								IF bit 20 == 0 THEN
									IF bit 22 == 0 THEN
										// LDRD reg
									ELSE
										// LDRD imm
									ENDIF
								ELSE
									IF bit 22 == 0 THEN
										// LDRSBT/LDRSB reg
									ELSE
										// LDRSBT/LDRSB imm
									ENDIF
								ENDIF
							ENDCASE

							CASE 3:
								// STRD/STRS
								IF bit 20 == 0 THEN
									IF bit 22 == 0 THEN
										// STRD reg
									ELSE
										// STRD imm
									ENDIF
								ELSE
									IF bit 22 == 0 THEN
										// LDRST/LDRS reg
									ELSE
										// LDRST/LDRS imm
									ENDIF
								ENDIF
							ENDCASE
						ENDCASEOF
					ENDIF
				ENDIF
			ENDCASE

			CASE 1:
				// Arith&log (imm) + specials + hints
				CASEOF (bits 24, 23)
						CASE 2:
							IF (bit 20 == 0) THEN
								// specials
								IF (bit 21 == 0) THEN
									IF (bit 22 == 0) THEN
										// MOVW
									ELSE
										// MOVT
									ENDIF
								ELSE
									// if R=0 and mask = 0 then hint instead of MSR
									IF ((bit 22 == 0) && (bits 19 - 16 == 0 0 0 0)) THEN
										CASEOF (bits 7 - 0)
											CASE 0:
												// NOP
											ENDCASE
											
											CASE 1:
												// YIELD
											ENDCASE
											
											CASE 2:
												// WFE
											ENDCASE
											
											CASE 3:
												// WFI
											ENDCASE
											
											CASE 4:
												// SEV
											ENDCASE
											
											OTHER:
												IF (bits 7 - 4 == 0xf) THEN
													// DBG
												ELSE
													// empty
												ENDIF
											ENDCASE
										ENDCASEOF
									ELSE
										// MSR imm
									ENDIF
								ENDIF
							ELSE
								// TST/TEQ/CMP/CMN (bits 22,21)
							ENDIF
						ENDCASE
						
						OTHER:
							// Arith&logic
							CASEOF (bits 22, 21)
							ENDCASEOF
						ENDCASE
				ENDCASEOF
			ENDCASE

			CASE 2:
				// Single data transfer (imm) (bits 24 - 20 = P U B W L)
				// Completely decoded
			ENDCASE

			CASE 3:
				IF (bit 4 == 0) THEN
					// LDR/STR (reg shifted) (bits 24 - 20 = P U B W L)
				ELSE
					// Media Instructions
					CASEOF (bits 24 - 23)
						CASE 0:
							// parallel add & sub
							CASEOF (bits 22 - 20)
								CASE 0:
									// empty
								ENDCASE

								CASE 1:
									// signed add & sub
									CASEOF (bits 7 - 5)
										CASE 0:
											// SADD16
										ENDCASE

										CASE 1:
											// SASX
										ENDCASE

										CASE 2:
											// SSAX
										ENDCASE

										CASE 3:
											// SSUB16
										ENDCASE

										CASE 4:
											// SADD8
										ENDCASE

										CASE 7:
											// SSUB8
										ENDCASE

										OTHER:
											// empty
										ENDCASE
									ENDCASEOF
								ENDCASE

								CASE 2:
									// signed saturating
									CASEOF (bits 7 - 5)
										CASE 0:
											// QADD16
										ENDCASE

										CASE 1:
											// QASX
										ENDCASE

										CASE 2:
											// QSAX
										ENDCASE

										CASE 3:
											// QSUB16
										ENDCASE

										CASE 4:
											// QADD8
										ENDCASE

										CASE 7:
											// QSUB8
										ENDCASE

										OTHER:
											// empty
										ENDCASE
									ENDCASEOF
								ENDCASE
								
								CASE 3:
									// signed halving
									CASEOF (bits 7 - 5)
										CASE 0:
											// SHADD16
										ENDCASE

										CASE 1:
											// SHASX
										ENDCASE

										CASE 2:
											// SHSAX
										ENDCASE

										CASE 3:
											// SHSUB16
										ENDCASE

										CASE 4:
											// SHADD8
										ENDCASE

										CASE 7:
											// SHSUB8
										ENDCASE

										OTHER:
											// empty
										ENDCASE
									ENDCASEOF
								ENDCASE

								CASE 4:
									// empty
								ENDCASE

								CASE 5:
									// unsigned add & sub
									CASEOF (bits 7 - 5)
										CASE 0:
											// UADD16
										ENDCASE

										CASE 1:
											// UASX
										ENDCASE

										CASE 2:
											// USAX
										ENDCASE

										CASE 3:
											// USUB16
										ENDCASE

										CASE 4:
											// UADD8
										ENDCASE

										CASE 7:
											// USUB8
										ENDCASE

										OTHER:
											// empty
										ENDCASE
									ENDCASEOF
								ENDCASE

								CASE 6:
									// signed saturating
									CASEOF (bits 7 - 5)
										CASE 0:
											// UQADD16
										ENDCASE

										CASE 1:
											// UQASX
										ENDCASE

										CASE 2:
											// UQSAX
										ENDCASE

										CASE 3:
											// UQSUB16
										ENDCASE

										CASE 4:
											// UQADD8
										ENDCASE

										CASE 7:
											// UQSUB8
										ENDCASE

										OTHER:
											// empty
										ENDCASE
									ENDCASEOF
								ENDCASE

								CASE 7:
									// unsigned halving
									CASEOF (bits 7 - 5)
										CASE 0:
											// UHADD16
										ENDCASE

										CASE 1:
											// UHASX
										ENDCASE

										CASE 2:
											// UHSAX
										ENDCASE

										CASE 3:
											// UHSUB16
										ENDCASE

										CASE 4:
											// UHADD8
										ENDCASE

										CASE 7:
											// UHSUB8
										ENDCASE

										OTHER:
											// empty
										ENDCASE
									ENDCASEOF
								ENDCASE
							ENDCASEOF
						ENDCASE
						
						CASE 1:
							// pack / sat / rev
							IF (bit 5 == 0) THEN
								CASEOF (bits 22 - 20)
									CASE 0:
										IF (bit 6 == 0) THEN
											// SEL
										ELSE
											IF (bits 19 - 16) == 1 1 1 1) THEN
												// SXTB16
											ELSE
												// SXTAB16
											ENDIF
										ENDIF
									ENDCASE
	
									CASE 2:
										IF (bit 6 == 0) THEN
											// SSAT16
										ELSE
											IF (bits 19 - 16) == 1 1 1 1) THEN
												// SXTB
											ELSE
												// SXTAB
											ENDIF
										ENDIF
									ENDCASE
	
									CASE 3:
										IF (bit 6 == 0) THEN
											IF (bit 7 == 0) THEN
												// REV
											ELSE
												// REV16
											ENDIF
										ELSE
											IF (bits 19 - 16) == 1 1 1 1) THEN
												// SXTH
											ELSE
												// SXTAH
											ENDIF
										ENDIF
									ENDCASE
	
									CASE 4:
										IF (bits 19 - 16) == 1 1 1 1) THEN
											// UXTB16
										ELSE
											// UXTAB16
										ENDIF
									ENDCASE
	
									CASE 6:
										IF (bit 6 == 0) THEN
											// USAT16
										ELSE
											IF (bits 19 - 16) == 1 1 1 1) THEN
												// UXTB
											ELSE
												// UXTAB
											ENDIF
										ENDIF
									ENDCASE
	
									CASE 7:
										IF (bit 6 == 0) THEN
											IF (bit 7 == 0) THEN
												// RBIT
											ELSE
												// REVSH
											ENDIF
										ELSE
											IF (bits 19 - 16) == 1 1 1 1) THEN
												// UXTH
											ELSE
												// UXTAH
											ENDIF
										ENDIF
									ENDCASE
									
									OTHER:
										// empty
									ENDCASE
								ENDCASEOF
							ELSE
								CASEOF (bits 22 - 21)
									CASE 0:
										// PKHBT
									ENDCASE
									
									CASE 1:
										// SSAT
									ENDCASE
									
									CASE 2:
										// empty
									ENDCASE
									
									CASE 3:
										// USAT
									ENDCASE
								ENDCASEOF
							ENDIF							
						ENDCASE
						
						CASE 2:
							// mul & div
							CASEOF (bits 22 - 20)
								CASE 0:
									IF (bit 6 == 0) THEN
										IF (bits 15 - 12 == 15) THEN
											// SMUAD
										ELSE
											// SMLAD
										ENDIF
									ELSE
										IF (bits 15 - 12 == 15) THEN
											// SMUSD
										ELSE
											// SMLSD
										ENDIF
									ENDIF
								ENDCASE
								
								CASE 1:
									// SDIV
								ENDCASE
								
								CASE 3:
									// UDIV
								ENDCASE
								
								CASE 4:
									IF (bit 6 == 0) THEN
										// SMLALD
									ELSE
										// SMLSLD
									ENDIF
								ENDCASE
								
								CASE 5:
									IF (bit 6 == 0) THEN
										IF (bits 15 - 12 == 15) THEN
											// SMMUL
										ELSE
											// SMMLA
										ENDIF
									ELSE
										// SMMLS
									ENDIF
								ENDCASE
								
								OTHER:
									// empty
								ENDCASE
							ENDCASEOF
						ENDCASE
						
						CASE 3:
							// diff sum & bits
							CASEOF (bits 22 - 21)
								CASE 0:
									IF (bits 15 - 12 == 15) THEN
										// USAD8
									ELSE
										// USADA8
									ENDIF
								ENDCASE
								
								CASE 1:
									// SBFX
								ENDCASE
								
								CASE 2:
									IF (bits 3 - 0 == 15) THEN
										// BFC
									ELSE
										// BFI
									ENDIF
								ENDCASE
								
								CASE 3:
									IF (bit 5 == 0) THEN
										// UBFX
									ELSE
										// UDF
									ENDIF
								ENDCASE
							ENDCASEOF
						ENDCASE
					ENDCASEOF
				ENDIF
			ENDCASE

			CASE 4:
				// LD/ST multiple
				IF (bit 22 == 1) THEN
					// with amode
				ELSE
					// normal
				ENDIF
			ENDCASE

			CASE 5:
				// Branch
				IF (bit 24 == 0) THEN
					// without link register
				ELSE
					// with link register
				ENDIF
			ENDCASE

			CASE 6:
				// empty
			ENDCASE

			CASE 7:
				IF (bit 24 == 1) THEN
					SVC
				ELSE
					// empty
				ENDIF
			ENDCASE
		ENDCASEOF
	ENDIF
ENDPROC
