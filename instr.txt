Most of the info needed here was found from:
http://www.wss.co.uk/pinknoise/ARMinstrs/ARMinstrs.html#Instructions
Kudos!

---------------------------------------
Deciphering ARM istruction set encoding

1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx E    AL(Always)	      branch
1111xxxx xxxxxxxx xxxxxxxx xxxxxxxx F    NV(Never)	      linear
Others are true conditionals

 Data Processing Instructions

xxxx000a aaaSnnnn ddddcccc ctttmmmm  Register form
xxxx001a aaaSnnnn ddddrrrr bbbbbbbb  Immediate form
        ADDEQS Rd, Rn, Rm, ASL Rc
if dddd = 1111 (PC) then branch, otherwise linear

 Branch Instructions
xxxx101L oooooooo oooooooo oooooooo

oooo... = offset = (sign extended version of bits 0-23)
destination address = current address + 8 + (4 * offset)
L = with link register

 Multiplication / Long Multiplication (ARM7DM)
xxxx0000 1UAShhhh llllssss 1001mmmm
The program counter, R15 should not be used.

 Single Data Transfer

xxxx010P UBWLnnnn ddddoooo oooooooo  Immediate form
xxxx011P UBWLnnnn ddddcccc ctt0mmmm  Register form
If the immediate form of the instruction is used, the o field gives
a 12-bit offset
If R15 is used as Rd, the PSR is not modified. The PC should not be used in Op2. 
Don't use writeback or post-indexing when the base register is the PC.
Don't use the PC as Rd for an LDRB or STRB.

 Block Data Transfer

xxxx100P USWLnnnn llllllll llllllll
The U bit indicates whether the address will be modified by +4 (set),
or -4 (clear) for each register.
The W bit always indicates writeback.
If set, the L bit indicates a load operation should be performed.
If clear, a save.
The P bit is used indicate whether to increment/decrement
the base before or after each load/store (see the table below).

Bit l is set if Rl is to be loaded/stored by this operation. 
Stub	Meaning                         P	U
DA	Decrement Rn After each store/load	0	0
DB	Decrement Rn Before each store/load	1	0
IA	Increment Rn After each store/load	0	1
IB	Increment Rn Before each store/load	1	1
The PC should not be used as the base register.

 Software interrupt

xxxx1111 yyyyyyyy yyyyyyyy yyyyyyyy

 Co-processor data operations

xxxx1110 oooonnnn ddddpppp qqq0mmmm
       CDP p, o, CRd, CRn, CRm, q

 Co-processor data transfer and register transfers

xxxx110P UNWLnnnn DDDDpppp oooooooo LDC/STC
xxxx1110 oooLNNNN ddddpppp qqq1MMMM MRC/MCR
       LDCNEL p,CRd,[Rn],#-100 ;long form (N=1), post-indexed
Rd should not be R15 for an MCR instruction.
If Rd is R15 for an MRC instruction, the top 4 bits of the word
transferred are used to set the flags; the remaining 28 bits are discarded.

 Single Data Swap (ARM 3 and later including ARM 2aS)

xxxx0001 0B00nnnn dddd0000 1001mmmm
None of Rd, Rn, and Rm may be R15

 Status Register transfer (ARM 6 and later)

xxxx0001 0s10aaaa 11110000 0000mmmm  MSR  Register form
xxxx0011 0s10aaaa 1111rrrr bbbbbbbb  MSR  Immediate form
xxxx0001 0s001111 dddd0000 00000000  MRS
Rd must not be R15.

 Undefined instructions

xxxx0001 yyyyyyyy yyyyyyyy 1yy1yyyy ARM 2 only
xxxx011y yyyyyyyy yyyyyyyy yyy1yyyy
On encountering an undefined instruction, the ARM switches to
Undef mode and jumps to undef exception.

------------

xxxxgggf fffyyyyy yyyyyyyy yyyyyyyy

xxxx: condition code

classes (ggg):
000	Data Processing Instructions - register form
	Multiplication, R15 should not be used
	Single Data Swap, None of Rd, Rn, and Rm may be R15
	MSR  Register form, Rd must not be R15
	MRS, Rd must not be R15
	Undefined instructions - ARM 2 only
001	Data Processing Instructions - immediate form
	MSR  Immediate form
010	Single Data Transfer - immediate form, if Rd=PC, check
011	Single Data Transfer - register form, if Rd=PC, check
	Undefined instructions - undef exception
100	Block Data Transfer - check
101	Branch Instructions
110	LDC/STC - linear (check)
111	Software interrupt
	Co-processor data operations
	MRC/MCR, if Rd = PC, check

The ff-bits (and bit-4) seem to make the secondary classification
gggffxx
000	Data Processing Instructions - register form
	0000	AND     	Boolean And     	Rd = Rn AND Op2
	0001	EOR     	Boolean Eor     	Rd = Rn EOR Op2
	0010	SUB     	Subtract        	Rd = Rn  -  Op2
	0011	RSB     	Reverse Subtract	Rd = Op2 -  Rn

	0100	ADD     	Addition        	bit4=0
	0101	ADC     	Add with Carry   	bit4=0
	0110	SBC     	Subtract with carry 	bit4=0
	0111	RSC     	Reverse sub w/carry 	bit4=0
	01UA	Multiplication bit4=1

	1000	TST     	Test bit        	bit4=0
	1001	TEQ     	Test equality   	bit4=0
	1010	CMP     	Compare         	bit4=0
	1011	CMN     	Compare Negative	bit4=0
	10B0	Single Data Swap bit4=1
	10s1	MSR  Register form bit4=1
	10s1	MRS bit4=1

	1100	ORR     	Boolean Or      	Rd = Rn OR  Op2
	1101	MOV     	Move value      	Rd =        Op2
	1110	BIC     	Bit clear       	Rd = Rn AND NOT Op2
	1111	MVN     	Move Not        	Rd =    NOT Op2

001	Data Processing Instructions - immediate form
	0000	AND     	Boolean And     	Rd = Rn AND Op2
	0001	EOR     	Boolean Eor     	Rd = Rn EOR Op2
	0010	SUB     	Subtract        	Rd = Rn  -  Op2
	0011	RSB     	Reverse Subtract	Rd = Op2 -  Rn

	0100	ADD     	Addition        	Rd = Rn  +  Op2
	0101	ADC     	Add with Carry   	Rd = Rn  +  Op2 + C
	0110	SBC     	Subtract with carry 	Rd = Rn  -  Op2 - (1-C)
	0111	RSC     	Reverse sub w/carry 	Rd = Op2 -  Rn  - (1-C)

	1000	TST     	Test bit        	Rn AND Op2
	1001	TEQ     	Test equality   	bit20=1
	1010	CMP     	Compare         	Rn  -  Op2
	1011	CMN     	Compare Negative	bit20=1
	10s1	MSR  Immediate form bit20=0

	1100	ORR     	Boolean Or      	Rd = Rn OR  Op2
	1101	MOV     	Move value      	Rd =        Op2
	1110	BIC     	Bit clear       	Rd = Rn AND NOT Op2
	1111	MVN     	Move Not        	Rd =    NOT Op2
	
010
	PUBW	Single Data Transfer - immediate form, if Rd=PC, check
011
	PUBW	(bit4 = 0) Single Data Transfer - register form, if Rd=PC, check
	yyyy	(bit4 = 1) Undefined instructions - undef exception (still exist?)
			(bit4 = 1) Media instructions (Rd = PC is not allowed or is UNPREDICTABLE)
100	
	PUSW	Block Data Transfer - check
101
	L		B (branch, L = with link reg)
110	
	PUNW	LDC/STC
111
	0ooo	Co-processor data operations (bit4 = 0)
	0ooo	MRC/MCR (bit4 = 1)
	1yyy	Software interrupt


Branches:
conditional branches are 'B'-branches with condition code
31:28 = condition code
27:25 (class) = 101
24 = L (1 = with LR)
23:0 = signed imm (PC-offset)
With condition NV (1111) it becomes BLX, where bit 24 tells what?

For register ops: bits 11-0 is a shifter operand:
register: 11:7 imm, 6:5=type, 4=0, 3:0=Rm
register-shifted: 11:8 = Rs, 7=0. 6:5=type, 4=1, 3:0=Rm operand2=Rm <type> Rs
type:
00 = LSL
01 = LSR
10 = ASR
11 = ROR
modified imm: 11:8 rot, 7:0 imm
rot = number of double shifts right

LDC/LDC2/STC/STC2
110 PUNWL Rn=19:16  CRd=15:12 cpnum=11:8 wordoffset=7:0

N=1 long transfer
PUWL as with LDR/STR (no usermode access => W is always writeback), L=1:LDC (mem->Cp)
U must equal 1 or the result is either UNDEFINED or UNPREDICTABLE
wordoffset specifies the immediate offset that is multiplied by 4, then added to
or subtracted from the value of Rn to form the address


LDM/STM
100 PUSWL Rn=19:16 reglist=15:0
PUWL as with LDC/STC
S: For LDMs that load the PC, the S bit indicates that the CPSR is loaded from the SPSR. For
LDMs that do not load the PC and all STMs, the S bit indicates that when the processor is in a
privileged mode, the User mode banked registers are transferred instead of the registers of
the current mode.
reglist: bit n = Register n included into the list
The SP and PC can be in the list in ARM instructions, but not in Thumb instructions.
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE

Single data transfer:
cond 01A op1(24:20) Rn(19:16) .... Bit4 ...
op1 bits: PUBWL
P=0: post indexing. P=1 offset or pre indexing (indexing = offset + writeback)
U=offset sign (1=+, 0=-)
W:
  P=0: W= user mode access (1=user, 0=normal)
  P=1: W= writeback (1=writeback)
PW is like unit (or one field with separated bits):
00 = postindexing, normal
01 = usermode access, offset
10 = offset normal
11 = preindexing normal
B=byte, L=direction:1=load

LDR reg, LDRB reg:
if m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;
if ArchVersion() < 6 && wback && m == n then UNPREDICTABLE
LDRT reg, LDRTB reg:
if PC is involved, UNPREDICTABLE
LDR imm, LDRB imm, LDRT imm, LDRTB imm:
Rd != PC
A op1
0 00000 STR imm
0 00001 LDR imm Rn != PC
0 00010	STRT
0 00011 LDRT 
0 00100 STRB imm
0 00101 LDRB imm Rn != PC
0 00110 STRBT
0 00111 LDRBT
0 01000 STR imm
0 01001 LDR imm Rn != PC
0 01010 STRT
0 01011 LDRT
0 01100 STRB imm
0 01101 LDRB imm Rn != PC
0 01110 STRBT
0 01111 LDRBT
0 10000 STR imm
0 10001 LDR imm Rn != PC
0 10010 STR imm
0 10011 LDR imm Rn != PC
0 10100 STRB imm
0 10101 LDRB imm Rn != PC
0 10110 STRB imm
0 10111 LDRB imm Rn != PC
0 11000 STR imm
0 11001 LDR imm Rn != PC
0 11010 STR imm
0 11011 LDR imm Rn != PC
0 11100 STRB imm
0 11101 LDRB imm Rn != PC
0 11110 STRB imm
0 11111 LDRB imm Rn != PC
1 00000 STR reg B=0
1 00001 LDR reg B=0
1 00010 STRT B=0
1 00011 LDRT B=0
1 00100 STRB reg B=0
1 00101 LDRB reg B=0
1 00110 STRBT B=0
1 00111 LDRBT B=0
1 01000 STR reg B=0
1 01001 LDR reg B=0
1 01010 STRT B=0
1 01011 LDRT B=0
1 01100 STRB reg B=0
1 01101 LDRB reg B=0
1 01110 STRBT B=0
1 01111 LDRBT B=0
1 10000 STR reg B=0
1 10001 LDR reg B=0
1 10010 STR reg B=0
1 10011 LDR reg B=0
1 10100 STRB reg B=0
1 10101 LDRB reg B=0
1 10110 STRB reg B=0
1 10111 LDRB reg B=0
1 11000 STR reg B=0
1 11001 LDR reg B=0
1 11010 STR reg B=0
1 11011 LDR reg B=0
1 11100 STRB reg B=0
1 11101 LDRB reg B=0
1 11110 STRB reg B=0
1 11111 LDRB reg B=0
All immediates (A=1) have bit4=0. If bit4=1 => media instruction

